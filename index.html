<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Racer Pro - Custom Background</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            background-color: #000;
            color: white;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 30, 0.8);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: right;
            min-width: 200px;
            border: 1px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.3);
            font-size: 1.2em;
            text-transform: uppercase;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        .ui-panel div {
            margin-bottom: 5px;
        }
        .ui-panel span {
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        #powerup-status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }
        .status-indicator {
            background: rgba(0, 20, 30, 0.8);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #00ffff88;
            font-size: 1.2em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .status-indicator.active {
            border-color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            transform: scale(1.1);
        }
        #shield-indicator { color: #00aaff; }
        #shield-indicator.active { box-shadow: 0 0 20px #00aaff; border-color: #00aaff; }
        #boost-indicator { color: #ffff00; }
        #boost-indicator.active { box-shadow: 0 0 20px #ffff00; border-color: #ffff00; }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000428, #004e92, #000428);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
        }
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #start-screen h1, #game-over h1 {
            font-size: 5em;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #00ffff, 0 0 40px #00ffff;
            margin-bottom: 20px;
        }
        #start-screen p, #loading-text {
            font-size: 1.2em;
            max-width: 80%;
            line-height: 1.8;
            color: #ddd;
        }
        .button {
            padding: 15px 40px;
            font-size: 1.5em;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            background: transparent;
            color: white;
            border: 2px solid #00ffff;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.3);
            transition: transform 0.2s, box-shadow 0.2s, color 0.2s, background 0.2s;
            text-transform: uppercase;
        }
        .button:hover {
            background: #00ffff;
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.8), inset 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        #touch-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: flex;
        }
        #touch-left, #touch-right {
            width: 50%;
            height: 100%;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- DRACOLoader script to decompress models -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
</head>
<body>
    <div id="container">
        <canvas id="game-canvas"></canvas>
        <div id="touch-controls">
            <div id="touch-left"></div>
            <div id="touch-right"></div>
        </div>
        <div class="ui-panel">
            <div>Score: <span id="score">0</span></div>
            <div>Distance: <span id="distance">0</span>m</div>
        </div>
        <div id="powerup-status">
            <div id="shield-indicator" class="status-indicator">Shield</div>
            <div id="boost-indicator" class="status-indicator">Boost</div>
        </div>
        <div id="start-screen" class="overlay">
            <h1 id="main-title">RACER PRO</h1>
            <p id="instructions">
                Use <strong>Left/Right Arrow Keys</strong> or <strong>Tap Screen Left/Right</strong> to steer.<br>
                Collect blue orbs for a shield and yellow orbs for a speed boost.
            </p>
            <p id="loading-text" style="display: none;">Loading Assets...</p>
            <button id="start-button" class="button">Start Racing</button>
        </div>
        <div id="game-over" class="overlay" style="display: none;">
            <h1>GAME OVER</h1>
            <div class="score-display" id="final-score" style="font-size: 2em;">Score: 0</div>
            <button id="restart-button" class="button">Try Again</button>
        </div>
    </div>

    <script type="module">
        // --- DOM Elements ---
        const gameCanvas = document.getElementById('game-canvas');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const scoreElement = document.getElementById('score');
        const distanceElement = document.getElementById('distance');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const shieldIndicator = document.getElementById('shield-indicator');
        const boostIndicator = document.getElementById('boost-indicator');
        const touchLeft = document.getElementById('touch-left');
        const touchRight = document.getElementById('touch-right');
        const loadingText = document.getElementById('loading-text');
        const instructions = document.getElementById('instructions');
        const mainTitle = document.getElementById('main-title');

        // --- Game Constants ---
        const LANE_POSITIONS = [-3.5, 0, 3.5];
        const LANE_CHANGE_SPEED = 0.15;
        const BASE_SPEED = 30;
        const OBSTACLE_SPAWN_Z = -150;
        const ROAD_WIDTH = 12;
        const ROAD_LENGTH = 1000;
        const INITIAL_FOV = 75;
        const BOOST_FOV = 90;

        // --- Game State ---
        let gameStarted = false, score = 0, distance = 0, currentLane = 1, targetLane = 1, gameOver = false;
        let gameSpeed = BASE_SPEED;
        let shieldActive = false, boostActive = false;
        let shieldTimeout, boostTimeout;

        // --- Three.js Setup ---
        let scene, camera, renderer, playerCar, particles;
        let roadSegments = [], obstacles = [], powerups = [];
        const clock = new THREE.Clock();
        const gltfLoader = new THREE.GLTFLoader();

        // --- DRACO Loader Setup ---
        const dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
        gltfLoader.setDRACOLoader(dracoLoader);

        async function initGameWorld() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 75, 200);

            camera = new THREE.PerspectiveCamera(INITIAL_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 12);
            
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            scene.add(new THREE.AmbientLight(0x404080, 1));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            playerCar = new THREE.Group();
            scene.add(playerCar);

            await Promise.all([
                loadPlayerCarModel(),
                loadBackgroundModel()
            ]);

            createRoadAndGround();
            window.addEventListener('resize', onWindowResize);
        }

        function loadPlayerCarModel() {
            return new Promise((resolve) => {
                const modelUrl = 'Toyota AE86.glb';
                gltfLoader.load(modelUrl, (gltf) => {
                    const model = gltf.scene;
                    model.scale.set(0.3, 0.3, 0.3);
                    model.rotation.y = Math.PI;
                    model.position.y = 0;
                    model.traverse(node => { if (node.isMesh) node.castShadow = true; });
                    playerCar.add(model);
                    resolve();
                }, undefined, (error) => {
                    console.error('Car model failed to load, creating fallback.', error);
                    createFallbackPlayerCar();
                    resolve();
                });
            });
        }
        
        function loadBackgroundModel() {
            return new Promise((resolve) => {
                const modelUrl = 'https://threejs.org/examples/models/gltf/LittlestTokyo.glb';
                gltfLoader.load(modelUrl, (gltf) => {
                    const backgroundScene = gltf.scene;
                    backgroundScene.scale.set(1, 1, 1);
                    backgroundScene.position.set(0, 0, -250);
                    backgroundScene.traverse(node => {
                        if (node.isMesh) {
                            node.receiveShadow = true;
                            node.material.metalness = 0.5;
                            node.material.roughness = 0.6;
                        }
                    });
                    scene.add(backgroundScene);
                    resolve();
                }, undefined, (error) => {
                    console.error('Background model failed to load.', error);
                    resolve();
                });
            });
        }
        
        function createFallbackPlayerCar() {
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff0055, metalness: 0.8, roughness: 0.2 });
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.6, 4), bodyMat);
            chassis.position.y = 0.6;
            chassis.castShadow = true;
            playerCar.add(chassis);
        }

        function createRoadAndGround() {
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.5 });
            for (let i = 0; i < 2; i++) {
                const segment = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH), roadMat);
                segment.rotation.x = -Math.PI / 2;
                segment.position.z = -i * ROAD_LENGTH / 2;
                segment.receiveShadow = true;
                scene.add(segment);
                roadSegments.push(segment);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            gameStarted = true;
            gameOver = false;
            score = 0;
            distance = 0;
            currentLane = 1;
            targetLane = 1;
            gameSpeed = BASE_SPEED;
            
            [...obstacles, ...powerups].forEach(obj => scene.remove(obj.mesh));
            if(particles) scene.remove(particles);
            obstacles = [];
            powerups = [];

            playerCar.position.set(LANE_POSITIONS[currentLane], 0, 0);
            
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            deactivateShield();
            deactivateBoost();

            animate();
        }

        function endGame() {
            gameStarted = false;
            gameOver = true;
            finalScoreElement.textContent = `Score: ${Math.floor(score)}`;
            gameOverScreen.style.display = 'flex';
        }

        function createObstacle() {
            const type = Math.random() > 0.3 ? 'car' : 'van';
            const lane = Math.floor(Math.random() * 3);
            const obstacle = new THREE.Group();
            
            const bodyMat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.6, 0.5), metalness: 0.6, roughness: 0.4 });
            const bodyGeo = type === 'car' ? new THREE.BoxGeometry(1.8, 0.8, 3.5) : new THREE.BoxGeometry(2, 2, 4);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            obstacle.add(body);

            obstacle.position.set(LANE_POSITIONS[lane], type === 'car' ? 0.4 : 1, OBSTACLE_SPAWN_Z);
            scene.add(obstacle);
            obstacles.push({ mesh: obstacle, lane: lane });
        }

        function createPowerup() {
            const type = Math.random() > 0.5 ? 'shield' : 'boost';
            const lane = Math.floor(Math.random() * 3);
            const geo = new THREE.IcosahedronGeometry(0.6, 1);
            const mat = new THREE.MeshStandardMaterial({ 
                color: type === 'shield' ? 0x00aaff : 0xffff00,
                emissive: type === 'shield' ? 0x00aaff : 0xffff00,
                emissiveIntensity: 2,
                roughness: 0.2,
                metalness: 0.5,
            });
            const powerupMesh = new THREE.Mesh(geo, mat);
            powerupMesh.position.set(LANE_POSITIONS[lane], 1.5, OBSTACLE_SPAWN_Z);
            scene.add(powerupMesh);
            powerups.push({ mesh: powerupMesh, type: type, lane: lane });
        }

        function applyShieldEffect(isActive) {
            const color = isActive ? 0x00aaff : 0x000000;
            playerCar.traverse(node => {
                if (node.isMesh && node.material && node.material.isMeshStandardMaterial) {
                    node.material.emissive.setHex(color);
                    node.material.emissiveIntensity = isActive ? 0.5 : 1;
                }
            });
        }

        function activateShield() {
            shieldActive = true;
            shieldIndicator.classList.add('active');
            applyShieldEffect(true);
            clearTimeout(shieldTimeout);
            shieldTimeout = setTimeout(deactivateShield, 5000);
        }
        function deactivateShield() {
            shieldActive = false;
            shieldIndicator.classList.remove('active');
            applyShieldEffect(false);
        }
        function activateBoost() {
            boostActive = true;
            boostIndicator.classList.add('active');
            gameSpeed = BASE_SPEED * 1.8;
            clearTimeout(boostTimeout);
            boostTimeout = setTimeout(deactivateBoost, 3000);
        }
        function deactivateBoost() {
            boostActive = false;
            boostIndicator.classList.remove('active');
            gameSpeed = BASE_SPEED;
        }

        function createExplosion(position) {
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                velocities.push(new THREE.Vector3((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20));
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.5, transparent: true, opacity: 1.0 });
            particles = new THREE.Points(geometry, material);
            particles.velocities = velocities;
            scene.add(particles);
        }

        let lastObstacleSpawn = 0;
        let lastPowerupSpawn = 0;
        
        function animate() {
            if (gameOver) return;
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            distance += gameSpeed * deltaTime;

            const targetX = LANE_POSITIONS[targetLane];
            playerCar.position.x = THREE.MathUtils.lerp(playerCar.position.x, targetX, LANE_CHANGE_SPEED);
            if (Math.abs(playerCar.position.x - targetX) < 0.1) currentLane = targetLane;

            const speed = gameSpeed * deltaTime;
            roadSegments.forEach(s => { s.position.z += speed; if (s.position.z > ROAD_LENGTH / 2) s.position.z -= ROAD_LENGTH; });
            
            if (distance - lastObstacleSpawn > 15) { createObstacle(); lastObstacleSpawn = distance; }
            if (distance - lastPowerupSpawn > 45) { createPowerup(); lastPowerupSpawn = distance; }

            const playerBox = new THREE.Box3().setFromObject(playerCar);
            
            obstacles.forEach((obs, index) => {
                obs.mesh.position.z += speed;
                if (obs.mesh.position.z > camera.position.z + 10) { scene.remove(obs.mesh); obstacles.splice(index, 1); score += 10; }
                const obsBox = new THREE.Box3().setFromObject(obs.mesh);
                if (playerBox.intersectsBox(obsBox)) {
                    if (shieldActive) {
                        createExplosion(obs.mesh.position);
                        scene.remove(obs.mesh);
                        obstacles.splice(index, 1);
                        score += 50;
                    } else {
                        endGame();
                    }
                }
            });

            powerups.forEach((pow, index) => {
                pow.mesh.position.z += speed;
                pow.mesh.rotation.y += 0.05;
                if (pow.mesh.position.z > camera.position.z + 10) { scene.remove(pow.mesh); powerups.splice(index, 1); }
                const powBox = new THREE.Box3().setFromObject(pow.mesh);
                if (playerBox.intersectsBox(powBox)) {
                    if (pow.type === 'shield') activateShield(); else if (pow.type === 'boost') activateBoost();
                    scene.remove(pow.mesh);
                    powerups.splice(index, 1);
                }
            });

            if (particles) {
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particles.velocities.length; i++) {
                    positions[i * 3] += particles.velocities[i].x * deltaTime;
                    positions[i * 3 + 1] += particles.velocities[i].y * deltaTime;
                    positions[i * 3 + 2] += particles.velocities[i].z * deltaTime;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.material.opacity -= deltaTime * 2;
                if (particles.material.opacity <= 0) {
                    scene.remove(particles);
                    particles = null;
                }
            }

            scoreElement.textContent = Math.floor(score);
            distanceElement.textContent = `${Math.floor(distance)}m`;
            
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, playerCar.position.x * 0.5, 0.1);
            camera.lookAt(playerCar.position.x, 2, -10);
            const targetFov = boostActive ? BOOST_FOV : INITIAL_FOV;
            camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, 0.1);
            camera.updateProjectionMatrix();
            
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        startButton.addEventListener('click', () => {
            if (playerCar.children.length > 0) {
                startGame();
            }
        });
        restartButton.addEventListener('click', startGame);

        document.addEventListener('keydown', (e) => {
            if (!gameStarted) return;
            if (e.key === 'ArrowLeft' && targetLane > 0) targetLane--;
            else if (e.key === 'ArrowRight' && targetLane < 2) targetLane++;
        });

        touchLeft.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gameStarted) return; if (targetLane > 0) targetLane--; }, { passive: false });
        touchRight.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gameStarted) return; if (targetLane < 2) targetLane++; }, { passive: false });

        // --- Initialization ---
        async function initialize() {
            mainTitle.style.display = 'none';
            instructions.style.display = 'none';
            startButton.style.display = 'none';
            loadingText.style.display = 'block';

            await initGameWorld();
            
            mainTitle.style.display = 'block';
            instructions.style.display = 'block';
            startButton.style.display = 'block';
            loadingText.style.display = 'none';
        }

        initialize();
    </script>
</body>
</html>
